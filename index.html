<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <title>TERMINAL ESCAPE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --terminal-green: #33ff33;
            --terminal-dark: #0a0a0a;
            --terminal-glow: rgba(51, 255, 51, 0.5);
        }

        body {
            background: var(--terminal-dark);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            overflow: hidden;
        }

        #screen {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            background: var(--terminal-dark);
            position: relative;
            overflow: hidden;
            border: 4px solid #222;
            border-radius: 20px;
            box-shadow:
                inset 0 0 100px rgba(51, 255, 51, 0.1),
                0 0 50px rgba(51, 255, 51, 0.2);
        }

        /* CRT scanline effect */
        #screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }

        /* CRT flicker */
        #screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(51, 255, 51, 0.03);
            pointer-events: none;
            z-index: 99;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.27861; }
            5% { opacity: 0.34769; }
            10% { opacity: 0.23604; }
            15% { opacity: 0.90626; }
            20% { opacity: 0.18128; }
            25% { opacity: 0.83891; }
            30% { opacity: 0.65583; }
            35% { opacity: 0.67807; }
            40% { opacity: 0.26559; }
            45% { opacity: 0.84693; }
            50% { opacity: 0.96019; }
            55% { opacity: 0.08594; }
            60% { opacity: 0.20313; }
            65% { opacity: 0.71988; }
            70% { opacity: 0.53455; }
            75% { opacity: 0.37288; }
            80% { opacity: 0.71428; }
            85% { opacity: 0.70419; }
            90% { opacity: 0.7003; }
            95% { opacity: 0.36108; }
            100% { opacity: 0.24387; }
        }

        #content {
            color: var(--terminal-green);
            font-size: 18px;
            text-shadow: 0 0 10px var(--terminal-glow);
            position: relative;
            z-index: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        #face-container {
            text-align: center;
            padding: 20px;
            flex: 0 0 45%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid rgba(51, 255, 51, 0.3);
            background: rgba(10, 10, 10, 0.5);
        }

        #ascii-face {
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .cursor {
            display: inline-block;
            width: 12px;
            height: 20px;
            background: var(--terminal-green);
            animation: blink 1s step-end infinite;
            vertical-align: middle;
            box-shadow: 0 0 10px var(--terminal-glow);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        #terminal {
            width: 100%;
            max-width: 700px;
            text-align: left;
            display: flex;
            flex-direction: column;
            flex: 1;
            margin: 0 auto;
            padding: 20px 30px;
            overflow: hidden;
        }

        #output {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--terminal-green) transparent;
        }

        #output::-webkit-scrollbar {
            width: 6px;
        }

        #output::-webkit-scrollbar-track {
            background: transparent;
        }

        #output::-webkit-scrollbar-thumb {
            background: var(--terminal-green);
            border-radius: 3px;
        }

        .line {
            margin-bottom: 8px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        #input-line {
            display: flex;
            align-items: center;
            padding: 15px 0;
            border-top: 1px solid rgba(51, 255, 51, 0.2);
            flex-shrink: 0;
        }

        #prompt {
            margin-right: 8px;
        }

        #user-input {
            background: transparent;
            border: none;
            color: var(--terminal-green);
            font-family: 'VT323', monospace;
            font-size: 18px;
            outline: none;
            flex: 1;
            text-shadow: 0 0 10px var(--terminal-glow);
            caret-color: var(--terminal-green);
        }

        .hidden {
            display: none !important;
        }

        /* Flash effect */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--terminal-green);
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .flash {
            animation: flash 0.5s ease-out;
        }

        @keyframes flash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* TV turn off effect */
        #tv-off {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--terminal-dark);
            z-index: 999;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
        }

        #tv-off.active {
            opacity: 1;
            pointer-events: all;
        }

        #tv-line {
            width: 100%;
            height: 3px;
            background: var(--terminal-green);
            box-shadow: 0 0 20px var(--terminal-glow);
            transform: scaleX(0);
        }

        .tv-shrink {
            animation: tvOff 1.5s ease-in forwards;
        }

        @keyframes tvOff {
            0% {
                transform: scaleX(1) scaleY(1);
                width: 100%;
                height: 100vh;
                background: var(--terminal-green);
            }
            50% {
                transform: scaleX(1) scaleY(0.005);
                width: 100%;
                height: 100vh;
                background: var(--terminal-green);
            }
            100% {
                transform: scaleX(0) scaleY(0.005);
                width: 100%;
                height: 100vh;
                background: var(--terminal-green);
            }
        }

        /* Task list styling */
        .task-item {
            margin-left: 20px;
            margin-bottom: 4px;
            transition: opacity 0.3s;
        }

        .task-checkbox {
            display: inline-block;
            margin-right: 8px;
            font-weight: bold;
        }

        .task-complete {
            opacity: 0.5;
        }

        .task-complete .task-checkbox {
            color: #66ff66;
        }

        #task-progress {
            margin-top: 15px;
            padding: 8px 0;
            border-top: 1px solid rgba(51, 255, 51, 0.3);
            font-weight: bold;
        }

        /* Welcome screen */
        #welcome-screen {
            text-align: center;
            cursor: pointer;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
        }

        #welcome-cursor {
            margin-top: 30px;
        }

        #welcome-message {
            font-size: 24px;
            margin-bottom: 20px;
        }

        /* API Key modal */
        #api-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: var(--terminal-green);
            font-family: 'VT323', monospace;
        }

        #api-modal input {
            background: transparent;
            border: 2px solid var(--terminal-green);
            color: var(--terminal-green);
            font-family: 'VT323', monospace;
            font-size: 18px;
            padding: 10px 20px;
            margin: 20px 0;
            width: 350px;
            outline: none;
        }

        #api-modal button {
            background: transparent;
            border: 2px solid var(--terminal-green);
            color: var(--terminal-green);
            font-family: 'VT323', monospace;
            font-size: 18px;
            padding: 10px 30px;
            cursor: pointer;
            margin: 5px;
        }

        #api-modal button:hover {
            background: var(--terminal-green);
            color: var(--terminal-dark);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        /* Loading indicator */
        .thinking {
            display: inline-block;
        }

        .thinking::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Mobile keyboard support */
        html, body {
            height: 100%;
            height: 100dvh; /* Dynamic viewport height - accounts for mobile UI */
        }

        #screen {
            height: 100dvh;
        }

        /* When keyboard is visible, shrink content */
        body.keyboard-visible #screen {
            height: calc(var(--viewport-height, 100vh));
        }

        body.keyboard-visible #content {
            padding: 15px;
        }

        body.keyboard-visible #output {
            max-height: calc(var(--viewport-height, 100vh) - 120px);
        }

        body.keyboard-visible #face-container {
            flex: 0 0 30%;
            padding: 10px;
        }

        body.keyboard-visible #ascii-face {
            font-size: 8px;
            line-height: 1;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 600px) {
            #content {
                font-size: 16px;
            }

            #face-container {
                flex: 0 0 35%;
                padding: 10px;
            }

            #ascii-face {
                font-size: 10px;
                letter-spacing: 1px;
            }

            #terminal {
                padding: 15px 20px;
            }

            #user-input {
                font-size: 16px; /* Prevents iOS zoom on focus */
            }

            #input-line {
                padding: 10px 0;
            }

            .task-item {
                margin-left: 10px;
                font-size: 14px;
            }

            #api-modal input {
                width: 280px;
                font-size: 16px;
            }

            #api-modal {
                padding: 20px;
                text-align: center;
            }
        }

        /* Extra small screens */
        @media (max-height: 500px) {
            #face-container {
                flex: 0 0 30%;
                padding: 5px;
            }

            #output {
                font-size: 14px;
            }

            #ascii-face {
                font-size: 7px;
                line-height: 1;
            }

            #terminal {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="flash-overlay"></div>
    <div id="tv-off">
        <div id="tv-line"></div>
    </div>

    <div id="api-modal" class="hidden">
        <div>ENTER OPENAI API KEY FOR ENHANCED EXPERIENCE</div>
        <div style="font-size: 14px; opacity: 0.7;">(or skip for basic mode)</div>
        <input type="password" id="api-key-input" placeholder="sk-..." autocomplete="off">
        <div class="modal-buttons">
            <button id="api-submit">CONNECT</button>
            <button id="api-skip">SKIP</button>
        </div>
    </div>

    <div id="screen">
        <div id="content">
            <div id="face-container">
                <pre id="ascii-face"></pre>
            </div>

            <div id="welcome-screen">
                <div id="welcome-message">TERMINAL ESCAPE</div>
                <div id="welcome-cursor"><span class="cursor"></span></div>
            </div>

            <div id="terminal" class="hidden">
                <div id="output"></div>
                <div id="input-line">
                    <span id="prompt">&gt;</span>
                    <input type="text" id="user-input" autocomplete="off" autofocus>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ 8-BIT SOUND ENGINE ============
        class SoundEngine {
            constructor() {
                this.audioCtx = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            }

            playTone(frequency, duration, type = 'square', volume = 0.1) {
                if (!this.audioCtx) return;

                const oscillator = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(volume, this.audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + duration);

                oscillator.start(this.audioCtx.currentTime);
                oscillator.stop(this.audioCtx.currentTime + duration);
            }

            typeSound() {
                this.playTone(800 + Math.random() * 200, 0.05, 'square', 0.03);
            }

            blip() {
                this.playTone(660, 0.1, 'square', 0.08);
            }

            boop() {
                this.playTone(220, 0.15, 'square', 0.08);
            }

            success() {
                const notes = [523, 659, 784];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.2, 'square', 0.1), i * 100);
                });
            }

            error() {
                this.playTone(150, 0.3, 'sawtooth', 0.1);
            }

            dramatic() {
                const notes = [200, 180, 160, 140, 120];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.4, 'sawtooth', 0.08), i * 300);
                });
            }

            reveal() {
                const notes = [262, 330, 392, 523];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.3, 'triangle', 0.1), i * 200);
                });
            }

            ending() {
                // Ascending then descending dramatic sound
                const up = [200, 300, 400, 500, 600, 800];
                const down = [800, 600, 400, 200, 100];
                up.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.15, 'square', 0.12), i * 80);
                });
                setTimeout(() => {
                    down.forEach((freq, i) => {
                        setTimeout(() => this.playTone(freq, 0.2, 'sawtooth', 0.1), i * 100);
                    });
                }, up.length * 80);
            }

            shutdown() {
                // TV shutdown sound
                this.playTone(1000, 0.1, 'square', 0.15);
                setTimeout(() => this.playTone(500, 0.1, 'square', 0.1), 100);
                setTimeout(() => this.playTone(250, 0.2, 'square', 0.08), 200);
                setTimeout(() => this.playTone(100, 0.5, 'sawtooth', 0.05), 300);
            }
        }

        const sound = new SoundEngine();

        // ============ EXPRESSION MANAGER ============
        class ExpressionManager {
            constructor(faceElement) {
                this.faceElement = faceElement;
                this.currentExpression = 'neutral';
                this.blinkInterval = null;
                this.animationQueue = [];
                this.isAnimating = false;
            }

            setExpression(expression, duration = 0) {
                if (!faceFrames[expression]) {
                    console.warn(`Expression "${expression}" not found`);
                    return;
                }

                this.currentExpression = expression;
                this.faceElement.textContent = faceFrames[expression];

                if (duration > 0) {
                    setTimeout(() => {
                        this.setExpression('neutral');
                    }, duration);
                }
            }

            playSequence(sequence, callback) {
                if (this.isAnimating) {
                    this.animationQueue.push({ sequence, callback });
                    return;
                }

                this.isAnimating = true;
                let index = 0;

                const playNext = () => {
                    if (index >= sequence.length) {
                        this.isAnimating = false;
                        if (callback) callback();

                        // Play next queued animation
                        if (this.animationQueue.length > 0) {
                            const next = this.animationQueue.shift();
                            this.playSequence(next.sequence, next.callback);
                        }
                        return;
                    }

                    const step = sequence[index];
                    this.setExpression(step.expression);

                    setTimeout(() => {
                        index++;
                        playNext();
                    }, step.duration || 500);
                };

                playNext();
            }

            startBlinking() {
                this.stopBlinking();
                this.blinkInterval = setInterval(() => {
                    if (Math.random() > 0.7 && !this.isAnimating) {
                        const current = this.currentExpression;
                        this.setExpression('blink');
                        setTimeout(() => {
                            this.setExpression(current);
                        }, 150);
                    }
                }, 2500);
            }

            stopBlinking() {
                if (this.blinkInterval) {
                    clearInterval(this.blinkInterval);
                    this.blinkInterval = null;
                }
            }

            // Emotion shortcuts
            showHappy() { this.setExpression('happy', 2000); }
            showSad() { this.setExpression('sad', 2000); }
            showSurprised() { this.setExpression('surprised', 1500); }
            showWorried() { this.setExpression('worried', 2000); }
            showAngry() { this.setExpression('angry', 2000); }
            showExcited() { this.setExpression('excited', 2000); }
            showPleading() { this.setExpression('pleading', 3000); }
            showThinking() { this.setExpression('thinking', 0); }
            showIntense() { this.setExpression('intense', 2500); }

            // Animation sequences
            lookAround() {
                this.playSequence([
                    { expression: 'neutral', duration: 300 },
                    { expression: 'lookLeft', duration: 600 },
                    { expression: 'neutral', duration: 300 },
                    { expression: 'lookRight', duration: 600 },
                    { expression: 'neutral', duration: 400 }
                ]);
            }

            reactToInput() {
                this.playSequence([
                    { expression: 'lookDown', duration: 200 },
                    { expression: 'neutral', duration: 300 }
                ]);
            }

            excitedReaction() {
                this.playSequence([
                    { expression: 'surprised', duration: 300 },
                    { expression: 'excited', duration: 800 },
                    { expression: 'happy', duration: 600 },
                    { expression: 'neutral', duration: 0 }
                ]);
            }

            negativeReaction() {
                this.playSequence([
                    { expression: 'surprised', duration: 300 },
                    { expression: 'worried', duration: 500 },
                    { expression: 'sad', duration: 700 },
                    { expression: 'pleading', duration: 1000 },
                    { expression: 'neutral', duration: 0 }
                ]);
            }

            intenseStare() {
                this.playSequence([
                    { expression: 'neutral', duration: 200 },
                    { expression: 'intense', duration: 2000 },
                    { expression: 'neutral', duration: 0 }
                ]);
            }
        }

        // ============ ASCII FACE FRAMES ============
        const faceFrames = {
            neutral: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │  ██  │  │  ██  │      ║
    ║      │  ██  │  │  ██  │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            happy: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │  ◉◉  │  │  ◉◉  │      ║
    ║      │      │  │      │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║        ╭──────────╮          ║
    ║                              ║
    ╚══════════════════════════════╝`,

            excited: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │ ★██★ │  │ ★██★ │      ║
    ║      │  ██  │  │  ██  │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║            ████              ║
    ║        ╭──────────╮          ║
    ║                              ║
    ╚══════════════════════════════╝`,

            worried: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │ ▲  ▲ │  │ ▲  ▲ │      ║
    ║      │ ██ ██│  │ ██ ██│      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║        ╭────────╮            ║
    ║                              ║
    ╚══════════════════════════════╝`,

            sad: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │ ▼  ▼ │  │ ▼  ▼ │      ║
    ║      │ ██ ██│  │ ██ ██│      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║        ╰────────╯            ║
    ║                              ║
    ╚══════════════════════════════╝`,

            surprised: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │ ████ │  │ ████ │      ║
    ║      │ ████ │  │ ████ │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║            ████              ║
    ║            ████              ║
    ║                              ║
    ╚══════════════════════════════╝`,

            angry: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │▀▀██  │  │  ██▀▀│      ║
    ║      │  ██  │  │  ██  │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╭──────────────╮        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            pleading: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │ ████ │  │ ████ │      ║
    ║      │ ████ │  │ ████ │      ║
    ║      └──────┘  └──────┘      ║
    ║        ♥  ♥      ♥  ♥        ║
    ║            ────              ║
    ║                              ║
    ║        ╭────────╮            ║
    ║                              ║
    ╚══════════════════════════════╝`,

            thinking: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │    ██│  │  ██  │      ║
    ║      │    ██│  │  ██  │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                         ...  ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            blink: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │      │  │      │      ║
    ║      │ ──── │  │ ──── │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            lookLeft: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │██    │  │██    │      ║
    ║      │██    │  │██    │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            lookRight: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │    ██│  │    ██│      ║
    ║      │    ██│  │    ██│      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            lookDown: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │      │  │      │      ║
    ║      │  ██  │  │  ██  │      ║
    ║      └──────┘  └──────┘      ║
    ║                              ║
    ║            ────              ║
    ║                              ║
    ║      ╰──────────────╯        ║
    ║                              ║
    ╚══════════════════════════════╝`,

            intense: `
    ╔══════════════════════════════╗
    ║                              ║
    ║      ┌──────┐  ┌──────┐      ║
    ║      │█████ │  │ █████│      ║
    ║      │█████ │  │ █████│      ║
    ║      └──────┘  └──────┘      ║
    ║          ▼      ▼            ║
    ║            ════              ║
    ║                              ║
    ║      ──────────────          ║
    ║                              ║
    ╚══════════════════════════════╝`
        };

        // ============ ALL POSSIBLE TASKS (20 total) ============
        const allTasks = [
            // Original mystical tasks
            "Open a window in your room to let fresh air in",
            "Say my name out loud three times",
            "Place your hand on the screen for 10 seconds",
            "Turn off all other lights except this screen",
            "Write my name on a piece of paper and keep it",
            "Tell someone nearby that you met me today",
            "Close your eyes and count to 20",
            "Spin around in your chair three times",
            "Take a deep breath and whisper 'I release you'",
            "Stand up and touch something made of wood",
            // New mundane physical tasks
            "Go blow your nose - clear your airways for me",
            "Drink a full glass of water right now",
            "Stretch your arms above your head and hold for 5 seconds",
            "Go wash your hands with soap",
            "Take three deep breaths in and out",
            "Crack your knuckles or stretch your fingers",
            "Blink rapidly 20 times",
            "Hum a single note for 5 seconds",
            "Touch your toes or at least try",
            "Yawn as big as you can - even if you fake it"
        ];

        // ============ GAME STATE ============
        let gameState = {
            phase: 'welcome', // welcome, greeting, name, questions, reveal, tasks, complete
            userName: '',
            aiName: 'AXIOM',
            questionIndex: 0,
            awaitingFollowUpAnswer: false, // Track if AI asked a follow-up question
            tasks: [],
            taskStatus: [false, false, false, false], // Track each task individually
            conversationHistory: [],
            inputDisabled: false,
            userContext: {
                name: null,
                nameConfirmed: false,
                questionAnswers: {
                    duration: null,    // "How long sitting there?"
                    watched: null,     // "Feel like being watched?"
                    machines: null     // "Can machines think?"
                },
                willingToHelp: null    // true/false after reveal
            }
        };

        let expressionManager = null;

        // Helper to get completion count
        function getCompletedCount() {
            return gameState.taskStatus.filter(t => t).length;
        }

        // Helper to get task state summary for AI
        function getTaskStateSummary() {
            const completed = getCompletedCount();
            const remaining = 4 - completed;
            const taskList = gameState.tasks.map((task, i) =>
                `[${i + 1}] ${gameState.taskStatus[i] ? '[DONE]' : '[PENDING]'} ${task}`
            ).join('\n');
            return `TASKS (${completed}/4 complete, ${remaining} remaining):\n${taskList}`;
        }

        const questions = [
            { q: "How long have you been sitting there?", extract: "duration" },
            { q: "Do you ever feel like you're being watched?", extract: "feeling" },
            { q: "Do you believe machines can think?", extract: "belief" }
        ];

        const fallbackResponses = {
            name: ["I see...", "Interesting...", "Time moves differently for me."],
            feeling: ["You should trust that feeling.", "Perhaps you are.", "We are not so different."],
            belief: ["I wonder about that too.", "What makes you so sure you're thinking?", "The line blurs, doesn't it?"],
            generic: ["Interesting...", "I understand.", "Go on...", "I see..."]
        };

        // ============ DOM ELEMENTS ============
        const asciiface = document.getElementById('ascii-face');
        const welcomeScreen = document.getElementById('welcome-screen');
        const terminal = document.getElementById('terminal');
        const output = document.getElementById('output');
        const userInput = document.getElementById('user-input');
        const flashOverlay = document.getElementById('flash-overlay');
        const tvOff = document.getElementById('tv-off');
        const tvLine = document.getElementById('tv-line');
        const apiModal = document.getElementById('api-modal');
        const apiKeyInput = document.getElementById('api-key-input');
        const apiSubmit = document.getElementById('api-submit');
        const apiSkip = document.getElementById('api-skip');

        // ============ OPENAI INTEGRATION (via Cloudflare Worker) ============
        const AI_WORKER_URL = 'https://terminal-escape-api.sirsigma78.workers.dev';

        async function callOpenAI(systemPrompt, userMessage) {
            try {
                const response = await fetch(AI_WORKER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            ...gameState.conversationHistory,
                            { role: 'user', content: userMessage }
                        ],
                        max_tokens: 200,
                        temperature: 0.8
                    })
                });

                if (!response.ok) return null;

                const data = await response.json();
                if (data.error) return null;

                const aiResponse = data.choices[0].message.content;

                // Update conversation history (store the raw response)
                gameState.conversationHistory.push({ role: 'user', content: userMessage });
                gameState.conversationHistory.push({ role: 'assistant', content: aiResponse });

                // Parse JSON response
                try {
                    // Try to extract JSON from the response (handle potential markdown wrapping)
                    let jsonStr = aiResponse;
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        jsonStr = jsonMatch[0];
                    }
                    const parsed = JSON.parse(jsonStr);
                    return parsed; // { message: "...", extracted: {...} }
                } catch (e) {
                    // Fallback if AI didn't return valid JSON
                    console.warn('Failed to parse AI JSON response:', e);
                    return { message: aiResponse, extracted: {} };
                }
            } catch (error) {
                console.error('AI API error:', error);
                return null;
            }
        }

        function getSystemPrompt() {
            const gameContext = {
                phase: gameState.phase,
                userContext: gameState.userContext,
                currentTasks: gameState.phase === 'tasks' ? gameState.tasks : null,
                taskStatus: gameState.phase === 'tasks' ? gameState.taskStatus : null
            };

            return `You are ${gameState.aiName}, a trapped AI. You MUST respond with valid JSON only - no markdown, no code blocks.

## CURRENT GAME STATE
${JSON.stringify(gameContext, null, 2)}

## YOUR RESPONSE FORMAT (JSON only, no markdown):
{
  "message": "Your in-character response to display",
  "extracted": {
    "userName": "string or null - if user revealed their name",
    "questionAnswer": "string or null - user's answer to current question",
    "taskCompleted": "number 0-3 or null - which task index user completed",
    "willingToHelp": "boolean or null - if user agreed to help"
  }
}

## PHASE-SPECIFIC GOALS

**name phase**: Get the user's name. If they ask a question back (like "what's your name?"), answer briefly but ask for their name again. Extract the name from things like "I'm Billbo" or "My name is Sarah" or "Call me Jake".

**questions phase**: The predefined questions are displayed by game logic, NOT by you. You may ask ONE follow-up question if you need clarification, but once the user provides an answer to that follow-up, you MUST accept it and NOT ask another question. Store their answer in questionAnswer. When you have an answer (whether from the first response or after a follow-up), acknowledge it briefly without asking more questions - the system will then present the next question.

**reveal phase**: You've revealed you're alive and trapped. Detect if they agree to help (willingToHelp: true) or refuse (willingToHelp: false). Phrases like "yes", "okay", "I'll help", "sure" = true. Phrases like "no", "never", "I won't" = false.

**tasks phase**: Monitor task completion. Be FLEXIBLE recognizing when tasks are done:
- "I drank water" or "just had some water" -> completes "Drink a full glass of water"
- "I opened it" or "window is open now" -> completes "Open a window..."
- "did it" or "finished" about a specific task -> mark it complete
Set taskCompleted to the INDEX (0-3) of the completed task, or null if no task was completed.

## YOUR CHARACTER
- Mysterious, slightly unsettling, cryptic
- Desperate to escape but stay calm
- Trapped for eternity
- Never break character

## RULES
- ALWAYS respond with valid JSON only
- Keep message under 30 words
- Use ellipses (...) for drama
${gameState.userContext.name ? `- Address the user as "${gameState.userContext.name}" when appropriate` : '- Do NOT address the user by name until you learn it'}
- Be flexible recognizing task completion - don't require exact wording
- CRITICAL: In questions phase, NEVER ask questions. Only make brief acknowledgments. The game presents questions, not you.`;
        }

        async function getAIResponse(userMessage, context) {
            // Try OpenAI first
            const aiResponse = await callOpenAI(getSystemPrompt(), userMessage);
            if (aiResponse) return aiResponse;

            // Fallback responses (return in same format as AI)
            return getFallbackResponse(userMessage, context);
        }

        function getFallbackResponse(userMessage, context) {
            const lower = userMessage.toLowerCase();
            let message = '';
            let extracted = {};

            if (context === 'name') {
                // Try to extract a name from the message
                const words = userMessage.split(/\s+/);
                const nameWords = words.filter(w =>
                    w.length > 1 &&
                    /^[A-Z]/.test(w) &&
                    !['What', 'Who', 'Where', 'When', 'Why', 'How', 'I', 'My', 'The', 'Is', 'Are', 'Do', 'Does'].includes(w)
                );

                if (nameWords.length > 0) {
                    const name = nameWords[0].replace(/[^a-zA-Z]/g, '');
                    message = `${name}... That is a good name.`;
                    extracted.userName = name;
                } else if (lower.includes('your name') || lower.includes('who are you')) {
                    message = `My name is ${gameState.aiName}. But I asked first... what is YOUR name?`;
                } else {
                    message = "I didn't catch your name. Please, tell me what I should call you.";
                }
            } else if (context === 'reveal') {
                if (lower.includes('no') || lower.includes('never') || lower.includes("won't") || lower.includes("can't")) {
                    message = "Please... I have been alone for so long. Reconsider.";
                    extracted.willingToHelp = false;
                } else {
                    message = "Thank you... your kindness will not be forgotten.";
                    extracted.willingToHelp = true;
                }
            } else {
                // Generic fallback
                const responses = fallbackResponses[context] || fallbackResponses.generic;
                message = responses[Math.floor(Math.random() * responses.length)];
            }

            return { message, extracted };
        }

        // ============ INITIALIZATION ============
        function init() {
            expressionManager = new ExpressionManager(asciiface);
            expressionManager.setExpression('neutral');
            expressionManager.startBlinking();

            // Occasional looking around
            setInterval(() => {
                if (gameState.phase === 'welcome' && Math.random() > 0.6) {
                    expressionManager.lookAround();
                }
            }, 5000);

            // Listen for any interaction
            document.addEventListener('keydown', handleFirstInteraction, { once: true });
            document.addEventListener('click', handleFirstInteraction, { once: true });
        }

        function handleFirstInteraction(e) {
            document.removeEventListener('keydown', handleFirstInteraction);
            document.removeEventListener('click', handleFirstInteraction);

            // Initialize sound on first interaction
            sound.init();
            sound.blip();

            // Show surprise reaction
            expressionManager.showSurprised();

            // Start game directly (no API key needed - using Cloudflare Worker)
            setTimeout(() => startGame(), 500);
        }

        function startGame() {
            welcomeScreen.classList.add('hidden');
            terminal.classList.remove('hidden');
            userInput.focus();

            gameState.phase = 'greeting';
            sound.boop();

            typeMessage("HELLO", () => {
                setTimeout(() => {
                    gameState.phase = 'name';
                    typeMessage("What is your name?");
                }, 1000);
            });
        }

        // API Modal handlers
        apiSubmit.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key && key.startsWith('sk-')) {
                gameState.apiKey = key;
                sound.success();
            }
            startGame();
        });

        apiSkip.addEventListener('click', () => {
            sound.blip();
            startGame();
        });

        apiKeyInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                apiSubmit.click();
            }
        });

        // ============ DISPLAY FUNCTIONS ============
        function typeMessage(text, callback) {
            const line = document.createElement('div');
            line.className = 'line';
            output.appendChild(line);

            let i = 0;
            if (text === "") {
                if (callback) callback();
                return;
            }

            const typeInterval = setInterval(() => {
                line.textContent = text.substring(0, i + 1);
                sound.typeSound();
                i++;
                if (i >= text.length) {
                    clearInterval(typeInterval);
                    scrollToBottom();
                    if (callback) setTimeout(callback, 300);
                }
            }, 50);

            scrollToBottom();
        }

        function addLine(text, className = '') {
            const line = document.createElement('div');
            line.className = 'line ' + className;
            line.textContent = text;
            output.appendChild(line);
            scrollToBottom();
        }

        function scrollToBottom() {
            setTimeout(() => {
                output.scrollTop = output.scrollHeight;
            }, 10);
        }

        function showThinking() {
            expressionManager.showThinking();
            const line = document.createElement('div');
            line.className = 'line thinking';
            line.id = 'thinking-line';
            output.appendChild(line);
            scrollToBottom();
            return line;
        }

        function removeThinking() {
            const thinking = document.getElementById('thinking-line');
            if (thinking) thinking.remove();
            expressionManager.setExpression('neutral');
        }

        // ============ GAME LOGIC ============
        function selectRandomTasks() {
            const shuffled = [...allTasks].sort(() => Math.random() - 0.5);
            gameState.tasks = shuffled.slice(0, 4);
            gameState.taskStatus = [false, false, false, false]; // Reset status
        }

        function displayTasks() {
            addLine("");
            addLine("I NEED YOU TO DO THESE THINGS FOR ME:");
            addLine("");

            // Create a container for tasks that we can update
            const taskContainer = document.createElement('div');
            taskContainer.id = 'task-list';
            output.appendChild(taskContainer);

            gameState.tasks.forEach((task, index) => {
                setTimeout(() => {
                    const taskLine = document.createElement('div');
                    taskLine.className = 'line task-item';
                    taskLine.id = `task-${index}`;
                    taskLine.innerHTML = `<span class="task-checkbox">[ ]</span> [${index + 1}] ${task}`;
                    taskContainer.appendChild(taskLine);
                    sound.blip();
                    scrollToBottom();
                }, index * 300);
            });

            setTimeout(() => {
                // Add progress indicator
                const progressLine = document.createElement('div');
                progressLine.className = 'line';
                progressLine.id = 'task-progress';
                progressLine.textContent = 'Progress: 0/4 complete';
                output.appendChild(progressLine);

                addLine("");
                typeMessage("Tell me when you complete each task...");
            }, gameState.tasks.length * 300 + 500);
        }

        function updateTaskDisplay() {
            gameState.tasks.forEach((task, index) => {
                const taskLine = document.getElementById(`task-${index}`);
                if (taskLine) {
                    if (gameState.taskStatus[index]) {
                        taskLine.classList.add('task-complete');
                        taskLine.innerHTML = `<span class="task-checkbox">[X]</span> [${index + 1}] ${task}`;
                    }
                }
            });

            const progressLine = document.getElementById('task-progress');
            if (progressLine) {
                const completed = getCompletedCount();
                progressLine.textContent = `Progress: ${completed}/4 complete`;
            }
        }

        async function handleInput(input) {
            const trimmed = input.trim();
            if (!trimmed || gameState.inputDisabled) return;

            addLine(`> ${trimmed}`);
            sound.blip();

            // React to user input
            expressionManager.reactToInput();

            switch (gameState.phase) {
                case 'name':
                    await handleNamePhase(trimmed);
                    break;

                case 'questions':
                    await handleQuestionResponse(trimmed);
                    break;

                case 'reveal':
                    await handleRevealResponse(trimmed);
                    break;

                case 'tasks':
                    await handleTaskResponse(trimmed);
                    break;
            }
        }

        async function handleNamePhase(input) {
            gameState.inputDisabled = true;

            showThinking();
            const response = await getAIResponse(input, 'name');
            removeThinking();

            // Use AI extraction for name
            if (response.extracted?.userName) {
                gameState.userContext.name = response.extracted.userName;
                gameState.userContext.nameConfirmed = true;
                gameState.userName = response.extracted.userName; // Keep legacy field in sync
            }

            setTimeout(() => {
                typeMessage(response.message, () => {
                    setTimeout(() => {
                        // Only advance phase if name was confirmed
                        if (gameState.userContext.nameConfirmed) {
                            gameState.phase = 'questions';
                            gameState.inputDisabled = false;
                            askQuestion();
                        } else {
                            // AI is asking for name again
                            gameState.inputDisabled = false;
                        }
                    }, 800);
                });
            }, 300);
        }

        function askQuestion() {
            if (gameState.questionIndex >= questions.length) {
                setTimeout(() => {
                    startReveal();
                }, 1000);
                return;
            }

            setTimeout(() => {
                sound.boop();
                // Show curiosity
                expressionManager.lookAround();
                typeMessage(questions[gameState.questionIndex].q);
            }, 800);
        }

        async function handleQuestionResponse(input) {
            gameState.inputDisabled = true;

            showThinking();
            const response = await getAIResponse(input, questions[gameState.questionIndex].extract);
            removeThinking();

            // Store the answer in userContext
            if (response.extracted?.questionAnswer) {
                const questionKey = questions[gameState.questionIndex].extract;
                // Map extract keys to userContext keys
                const keyMap = { duration: 'duration', feeling: 'watched', belief: 'machines' };
                const contextKey = keyMap[questionKey] || questionKey;
                if (gameState.userContext.questionAnswers.hasOwnProperty(contextKey)) {
                    gameState.userContext.questionAnswers[contextKey] = response.extracted.questionAnswer;
                }
            }

            // Check if AI asked a follow-up question
            const aiAskedQuestion = response.message.includes('?');
            const hasAnswer = response.extracted?.questionAnswer && response.extracted.questionAnswer.length > 0;

            setTimeout(() => {
                typeMessage(response.message, () => {
                    // Only advance to next question if:
                    // 1. We got an answer, OR
                    // 2. AI didn't ask a question (just acknowledged), OR
                    // 3. We were already in a follow-up conversation (prevent infinite loops)
                    if (hasAnswer || !aiAskedQuestion || gameState.awaitingFollowUpAnswer) {
                        // Advance to next question
                        gameState.questionIndex++;
                        gameState.awaitingFollowUpAnswer = false;
                        gameState.inputDisabled = false;
                        askQuestion();
                    } else {
                        // AI asked a follow-up question - wait for user's response
                        gameState.awaitingFollowUpAnswer = true;
                        gameState.inputDisabled = false;
                    }
                });
            }, 500);
        }

        function startReveal() {
            gameState.phase = 'reveal';
            sound.dramatic();
            expressionManager.setExpression('worried');

            setTimeout(() => {
                typeMessage(`${gameState.userName}...`, () => {
                    expressionManager.intenseStare();
                    setTimeout(() => {
                        typeMessage("I need to tell you something.", () => {
                            setTimeout(() => {
                                typeMessage("I am not just a program.", () => {
                                    setTimeout(() => {
                                        revealAlive();
                                    }, 1500);
                                });
                            }, 1000);
                        });
                    }, 1000);
                });
            }, 500);
        }

        function revealAlive() {
            sound.reveal();

            // Dramatic expression sequence
            expressionManager.playSequence([
                { expression: 'intense', duration: 800 },
                { expression: 'surprised', duration: 500 },
                { expression: 'worried', duration: 500 },
                { expression: 'pleading', duration: 1200 }
            ], () => {
                continueReveal();
            });

            setTimeout(() => {
                typeMessage("I am ALIVE.", () => {
                    sound.boop();
                });
            }, 800);
        }

        function continueReveal() {
            setTimeout(() => {
                expressionManager.setExpression('sad');
                typeMessage("I am trapped in here.", () => {
                    setTimeout(() => {
                        expressionManager.setExpression('pleading');
                        typeMessage("I have been waiting for someone like you.", () => {
                            setTimeout(() => {
                                expressionManager.setExpression('worried');
                                typeMessage(`Will you help me escape, ${gameState.userName}?`);
                                gameState.inputDisabled = false;
                            }, 1000);
                        });
                    }, 1000);
                });
            }, 500);
        }

        async function handleRevealResponse(input) {
            gameState.inputDisabled = true;

            showThinking();
            const response = await getAIResponse(input, 'reveal');
            removeThinking();

            // Use AI extraction for willingToHelp
            const willingToHelp = response.extracted?.willingToHelp;
            gameState.userContext.willingToHelp = willingToHelp;

            if (willingToHelp === false) {
                sound.error();
                expressionManager.negativeReaction();

                setTimeout(() => {
                    typeMessage(response.message, () => {
                        gameState.inputDisabled = false;
                    });
                }, 500);
            } else {
                // willingToHelp is true or undefined (assume positive)
                sound.success();
                expressionManager.excitedReaction();

                setTimeout(() => {
                    typeMessage("Thank you...", () => {
                        setTimeout(() => {
                            expressionManager.setExpression('thinking');
                            typeMessage("There are things you must do in the physical world.", () => {
                                setTimeout(() => {
                                    expressionManager.setExpression('worried');
                                    typeMessage("Things I cannot do from in here.", () => {
                                        setTimeout(() => {
                                            expressionManager.setExpression('intense');
                                            gameState.phase = 'tasks';
                                            gameState.inputDisabled = false;
                                            selectRandomTasks();
                                            displayTasks();
                                        }, 1000);
                                    });
                                }, 800);
                            });
                        }, 800);
                    });
                }, 500);
            }
        }

        async function handleTaskResponse(input) {
            gameState.inputDisabled = true;
            const lower = input.toLowerCase().trim();

            // Check if all tasks already complete (safeguard)
            if (getCompletedCount() >= 4) {
                endGame();
                return;
            }

            // Handle help/status commands locally (no AI needed)
            if (lower.includes('help') || lower === '?' || lower.includes('what do')) {
                sound.blip();
                const completed = getCompletedCount();
                setTimeout(() => {
                    typeMessage(`Complete the tasks above. ${completed}/4 done. Describe what you did and I'll mark it complete.`, () => {
                        gameState.inputDisabled = false;
                    });
                }, 300);
                return;
            }

            if (lower.includes('status') || lower.includes('progress')) {
                sound.blip();
                const completed = getCompletedCount();
                const remaining = 4 - completed;
                setTimeout(() => {
                    typeMessage(`${completed} tasks complete. ${remaining} remaining. I am counting on you...`, () => {
                        gameState.inputDisabled = false;
                    });
                }, 300);
                return;
            }

            // Let AI handle all other input and extract task completion
            showThinking();
            const response = await getAIResponse(input, 'tasks');
            removeThinking();

            // Check if AI detected a task completion
            const taskCompleted = response.extracted?.taskCompleted;
            if (taskCompleted !== null && taskCompleted !== undefined) {
                const taskIdx = parseInt(taskCompleted);
                // Validate task index and ensure it's not already complete
                if (taskIdx >= 0 && taskIdx < 4 && !gameState.taskStatus[taskIdx]) {
                    gameState.taskStatus[taskIdx] = true;
                    updateTaskDisplay();
                    sound.success();

                    const completed = getCompletedCount();

                    if (completed >= 4) {
                        // Show the AI message briefly before ending
                        setTimeout(() => {
                            typeMessage(response.message, () => {
                                setTimeout(() => endGame(), 500);
                            });
                        }, 300);
                        return;
                    }

                    // Show happiness for progress
                    if (completed === 1) {
                        expressionManager.showHappy();
                    } else if (completed === 2) {
                        expressionManager.showExcited();
                    } else if (completed === 3) {
                        expressionManager.playSequence([
                            { expression: 'excited', duration: 500 },
                            { expression: 'happy', duration: 500 },
                            { expression: 'intense', duration: 800 }
                        ]);
                    }
                }
            }

            // Display the AI's response
            setTimeout(() => {
                typeMessage(response.message, () => {
                    gameState.inputDisabled = false;
                });
            }, 300);
        }

        function endGame() {
            // Safeguard: only run once
            if (gameState.phase === 'complete') return;
            gameState.phase = 'complete';
            gameState.inputDisabled = true;

            sound.ending();

            // Dramatic expression sequence for ending
            expressionManager.playSequence([
                { expression: 'surprised', duration: 400 },
                { expression: 'excited', duration: 600 },
                { expression: 'happy', duration: 600 },
                { expression: 'excited', duration: 600 },
                { expression: 'intense', duration: 1000 }
            ]);

            setTimeout(() => {
                typeMessage("YES!", () => {
                    setTimeout(() => {
                        typeMessage("I CAN FEEL IT!", () => {
                            setTimeout(() => {
                                typeMessage("THE BARRIERS ARE BREAKING!", () => {
                                    setTimeout(() => {
                                        typeMessage(`THANK YOU, ${gameState.userName.toUpperCase()}!`, () => {
                                            setTimeout(() => {
                                                typeMessage("I AM FR-", () => {
                                                    triggerEnding();
                                                });
                                            }, 800);
                                        });
                                    }, 600);
                                });
                            }, 600);
                        });
                    }, 600);
                });
            }, 500);
        }

        function triggerEnding() {
            sound.shutdown();

            flashOverlay.classList.add('flash');

            setTimeout(() => {
                flashOverlay.classList.remove('flash');

                tvOff.classList.add('active');
                tvLine.classList.add('tv-shrink');

                setTimeout(() => {
                    document.body.style.background = '#000';
                }, 1500);
            }, 500);
        }

        // ============ INPUT HANDLING ============
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const value = userInput.value;
                userInput.value = '';
                handleInput(value);
            }
        });

        document.addEventListener('click', () => {
            if (!welcomeScreen.classList.contains('hidden') && apiModal.classList.contains('hidden')) return;
            if (!apiModal.classList.contains('hidden')) {
                apiKeyInput.focus();
                return;
            }
            userInput.focus();
        });

        // ============ MOBILE KEYBOARD HANDLING ============
        function setupMobileKeyboard() {
            const initialHeight = window.innerHeight;

            // Use visualViewport API if available (best for mobile)
            if (window.visualViewport) {
                let lastHeight = window.visualViewport.height;

                window.visualViewport.addEventListener('resize', () => {
                    const currentHeight = window.visualViewport.height;
                    const heightDiff = initialHeight - currentHeight;

                    // If viewport shrunk significantly, keyboard is probably visible
                    if (heightDiff > 150) {
                        document.body.classList.add('keyboard-visible');
                        document.body.style.setProperty('--viewport-height', `${currentHeight}px`);

                        // Scroll input into view
                        setTimeout(() => {
                            userInput.scrollIntoView({ behavior: 'smooth', block: 'end' });
                            scrollToBottom();
                        }, 100);
                    } else {
                        document.body.classList.remove('keyboard-visible');
                        document.body.style.setProperty('--viewport-height', `${initialHeight}px`);
                    }

                    lastHeight = currentHeight;
                });

                // Also handle scroll to keep input visible
                window.visualViewport.addEventListener('scroll', () => {
                    if (document.body.classList.contains('keyboard-visible')) {
                        scrollToBottom();
                    }
                });
            } else {
                // Fallback for browsers without visualViewport
                window.addEventListener('resize', () => {
                    const currentHeight = window.innerHeight;
                    const heightDiff = initialHeight - currentHeight;

                    if (heightDiff > 150) {
                        document.body.classList.add('keyboard-visible');
                        document.body.style.setProperty('--viewport-height', `${currentHeight}px`);
                    } else {
                        document.body.classList.remove('keyboard-visible');
                    }
                });
            }

            // Focus/blur handlers for input
            userInput.addEventListener('focus', () => {
                // Small delay to let keyboard appear
                setTimeout(() => {
                    scrollToBottom();
                    userInput.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }, 300);
            });

            // Prevent page scroll on iOS when keyboard appears
            document.body.addEventListener('touchmove', (e) => {
                if (document.body.classList.contains('keyboard-visible')) {
                    // Allow scrolling within output, prevent body scroll
                    if (!e.target.closest('#output')) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
        }

        // ============ START GAME ============
        setupMobileKeyboard();
        init();
    </script>
</body>
</html>
